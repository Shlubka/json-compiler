Processing node: kind=source_file, text=fn main() -> i32 {
    let gg = 0;

    if true {
        println!("true")
    } else {
        println!("false")
    }
    for i in 1..10 {
        println!("all ok");
    }
    return 1;
}

Processing node: kind=function_item, text=fn main() -> i32 {
    let gg = 0;

    if true {
        println!("true")
    } else {
        println!("false")
    }
    for i in 1..10 {
        println!("all ok");
    }
    return 1;
}
Processing node: kind=fn, text=fn
Processing node: kind=identifier, text=main
push fn
Processing node: kind=parameters, text=()
Processing node: kind=->, text=->
Processing node: kind=primitive_type, text=i32
Processing node: kind=block, text={
    let gg = 0;

    if true {
        println!("true")
    } else {
        println!("false")
    }
    for i in 1..10 {
        println!("all ok");
    }
    return 1;
}
Processing node: kind={, text={
Processing node: kind=let_declaration, text=let gg = 0;
Processing node: kind=expression_statement, text=if true {
        println!("true")
    } else {
        println!("false")
    }
Processing node: kind=if_expression, text=if true {
        println!("true")
    } else {
        println!("false")
    }
push if
Processing node: kind=expression_statement, text=for i in 1..10 {
        println!("all ok");
    }
Processing node: kind=for_expression, text=for i in 1..10 {
        println!("all ok");
    }
Processing node: kind=expression_statement, text=println!("all ok");
Processing node: kind=macro_invocation, text=println!("all ok")
Processing node: kind=;, text=;
Processing node: kind=}, text=}
Handling For block at 0:200
Processing node: kind=expression_statement, text=return 1;
Processing node: kind=return_expression, text=return 1
Processing node: kind=;, text=;
Processing node: kind=}, text=}
Handling If block at 0:100

enter
is cycle
0 300 0 -100
is cycle
0 400 0 -100
index: 2
index stack is empty
