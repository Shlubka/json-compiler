Processing node: kind=source_file, text=/*use rand::Rng;
use std::collections::{HashSet, VecDeque};
use std::io::{self, Write};
use std::time::Instant;

fn read_from_keyboard() -> u32 {
    io::stdout().flush().expect("flush error");
    let mut input_text = String::new();
    io::stdin()
        .read_line(&mut input_text)
        .expect("failed to read from stdin");

    let trimmed = input_text.trim();
    if let Ok(i) = trimmed.parse::<u32>() {
        return i;
    } else {
        println!("\x1b[31m!!!No number in input, установлено значение по умолчанию(10)!!!\x1b[0m");
        return 10;
    }
}*/

fn create_graph(size: usize) -> Vec<Vec<u32>> {
    let mut rng = rand::thread_rng();
    let mut graf = vec![vec![0u32; size]; size];

    for i in 0..size {
        for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
    }

    return graf;
}

/*fn create_adjacency_list(graf: &Vec<Vec<u32>>) -> Vec<Vec<usize>> {
    let size = graf.len();
    let mut adj_list = vec![vec![]; size];

    for i in 0..size {
        for j in 0..size {
            if graf[i][j] == 1 {
                adj_list[i].push(j);
            }
        }
    }

    return adj_list;
}

fn bfs_matrix(graf: &Vec<Vec<u32>>, start: usize) -> Vec<usize> {
    let num_vertices = graf.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut queue = VecDeque::new();
    queue.push_back(start);
    distances[start] = 0;

    while let Some(vertex) = queue.pop_front() {
        if !visited[vertex] {
            visited[vertex] = true;
            for neighbour in 0..num_vertices {
                if graf[vertex][neighbour] == 1 && !visited[neighbour] {
                    queue.push_back(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn bfs_list(adj_list: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {
    let num_vertices = adj_list.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut queue = VecDeque::new();
    queue.push_back(start);
    distances[start] = 0;

    while let Some(vertex) = queue.pop_front() {
        if !visited[vertex] {
            visited[vertex] = true;
            for &neighbour in &adj_list[vertex] {
                if !visited[neighbour] {
                    queue.push_back(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn dfs_matrix(graf: &Vec<Vec<u32>>, start: usize) -> Vec<usize> {
    let num_vertices = graf.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut stack = vec![start];
    distances[start] = 0;

    while let Some(vertex) = stack.pop() {
        if !visited[vertex] {
            visited[vertex] = true;
            for neighbour in (0..num_vertices).rev() {
                if graf[vertex][neighbour] == 1 && !visited[neighbour] {
                    stack.push(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn dfs_list(adj_list: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {
    let num_vertices = adj_list.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut stack = vec![start];
    distances[start] = 0;

    while let Some(vertex) = stack.pop() {
        if !visited[vertex] {
            visited[vertex] = true;
            for &neighbour in adj_list[vertex].iter().rev() {
                if !visited[neighbour] {
                    stack.push(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn main() {
    print!("Enter graph size, more than 0 (one number for line and column) > ");
    let size = read_from_keyboard();
    let graf = create_graph(size as usize);

    println!("Graph:");
    for row in &graf {
        println!("{:?}", row);
    }

    println!("BFS using matrix");
    let start = Instant::now();
    let distances = bfs_matrix(&graf, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    let adj_list = create_adjacency_list(&graf);
    println!("Graph:");
    for row in &adj_list {
        println!("{:?}", row);
    }
    println!("BFS using adjacency list:");
    let start = Instant::now();
    let distances = bfs_list(&adj_list, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    println!("DFS using matrix");
    let start = Instant::now();
    let distances = dfs_matrix(&graf, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    println!("DFS using adjacency list:");
    let start = Instant::now();
    let distances = dfs_list(&adj_list, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);
}
*/

Processing node: kind=block_comment, text=/*use rand::Rng;
use std::collections::{HashSet, VecDeque};
use std::io::{self, Write};
use std::time::Instant;

fn read_from_keyboard() -> u32 {
    io::stdout().flush().expect("flush error");
    let mut input_text = String::new();
    io::stdin()
        .read_line(&mut input_text)
        .expect("failed to read from stdin");

    let trimmed = input_text.trim();
    if let Ok(i) = trimmed.parse::<u32>() {
        return i;
    } else {
        println!("\x1b[31m!!!No number in input, установлено значение по умолчанию(10)!!!\x1b[0m");
        return 10;
    }
}*/
Processing node: kind=function_item, text=fn create_graph(size: usize) -> Vec<Vec<u32>> {
    let mut rng = rand::thread_rng();
    let mut graf = vec![vec![0u32; size]; size];

    for i in 0..size {
        for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
    }

    return graf;
}
Processing node: kind=fn, text=fn
Processing node: kind=identifier, text=create_graph
12
push fn
Processing node: kind=parameters, text=(size: usize)
Processing node: kind=->, text=->
Processing node: kind=generic_type, text=Vec<Vec<u32>>
Processing node: kind=block, text={
    let mut rng = rand::thread_rng();
    let mut graf = vec![vec![0u32; size]; size];

    for i in 0..size {
        for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
    }

    return graf;
}
Processing node: kind={, text={
Processing node: kind=let_declaration, text=let mut rng = rand::thread_rng();
Processing node: kind=let_declaration, text=let mut graf = vec![vec![0u32; size]; size];
Processing node: kind=expression_statement, text=for i in 0..size {
        for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
    }
Processing node: kind=for_expression, text=for i in 0..size {
        for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
    }
push for
Processing node: kind=expression_statement, text=for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
Processing node: kind=for_expression, text=for j in i..size {
            if i == j {
                continue;
            }
            graf[i][j] = rng.gen::<u32>() % 2;
            graf[j][i] = graf[i][j];
        }
push for
Processing node: kind=expression_statement, text=if i == j {
                continue;
            }
Processing node: kind=if_expression, text=if i == j {
                continue;
            }
push if
local_offset == 0, else_count = 0, else_if_count == 0
Processing node: kind=expression_statement, text=continue;
Processing node: kind=continue_expression, text=continue
Processing node: kind=;, text=;
Processing node: kind=}, text=}
Some(If(0, 300, 0))
len of block mass = 4
Handling If block at 0:300
Processing node: kind=expression_statement, text=graf[i][j] = rng.gen::<u32>() % 2;
Processing node: kind=assignment_expression, text=graf[i][j] = rng.gen::<u32>() % 2
Processing node: kind=;, text=;
Processing node: kind=expression_statement, text=graf[j][i] = graf[i][j];
Processing node: kind=assignment_expression, text=graf[j][i] = graf[i][j]
Processing node: kind=;, text=;
Processing node: kind=}, text=}
Some(For(0, 200))
len of block mass = 3
Handling For block at 0:200
Processing node: kind=}, text=}
Some(For(0, 100))
len of block mass = 2
Handling For block at 0:100
Processing node: kind=expression_statement, text=return graf;
Processing node: kind=return_expression, text=return graf
push return
Processing node: kind=;, text=;
Processing node: kind=}, text=}
Some(Func)
len of block mass = 1
Handling Func block
skip brecket
Processing node: kind=block_comment, text=/*fn create_adjacency_list(graf: &Vec<Vec<u32>>) -> Vec<Vec<usize>> {
    let size = graf.len();
    let mut adj_list = vec![vec![]; size];

    for i in 0..size {
        for j in 0..size {
            if graf[i][j] == 1 {
                adj_list[i].push(j);
            }
        }
    }

    return adj_list;
}

fn bfs_matrix(graf: &Vec<Vec<u32>>, start: usize) -> Vec<usize> {
    let num_vertices = graf.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut queue = VecDeque::new();
    queue.push_back(start);
    distances[start] = 0;

    while let Some(vertex) = queue.pop_front() {
        if !visited[vertex] {
            visited[vertex] = true;
            for neighbour in 0..num_vertices {
                if graf[vertex][neighbour] == 1 && !visited[neighbour] {
                    queue.push_back(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn bfs_list(adj_list: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {
    let num_vertices = adj_list.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut queue = VecDeque::new();
    queue.push_back(start);
    distances[start] = 0;

    while let Some(vertex) = queue.pop_front() {
        if !visited[vertex] {
            visited[vertex] = true;
            for &neighbour in &adj_list[vertex] {
                if !visited[neighbour] {
                    queue.push_back(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn dfs_matrix(graf: &Vec<Vec<u32>>, start: usize) -> Vec<usize> {
    let num_vertices = graf.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut stack = vec![start];
    distances[start] = 0;

    while let Some(vertex) = stack.pop() {
        if !visited[vertex] {
            visited[vertex] = true;
            for neighbour in (0..num_vertices).rev() {
                if graf[vertex][neighbour] == 1 && !visited[neighbour] {
                    stack.push(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn dfs_list(adj_list: &Vec<Vec<usize>>, start: usize) -> Vec<usize> {
    let num_vertices = adj_list.len();
    let mut visited = vec![false; num_vertices];
    let mut distances = vec![usize::MAX; num_vertices];
    let mut stack = vec![start];
    distances[start] = 0;

    while let Some(vertex) = stack.pop() {
        if !visited[vertex] {
            visited[vertex] = true;
            for &neighbour in adj_list[vertex].iter().rev() {
                if !visited[neighbour] {
                    stack.push(neighbour);
                    distances[neighbour] = distances[vertex] + 1;
                }
            }
        }
    }

    return distances;
}

fn main() {
    print!("Enter graph size, more than 0 (one number for line and column) > ");
    let size = read_from_keyboard();
    let graf = create_graph(size as usize);

    println!("Graph:");
    for row in &graf {
        println!("{:?}", row);
    }

    println!("BFS using matrix");
    let start = Instant::now();
    let distances = bfs_matrix(&graf, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    let adj_list = create_adjacency_list(&graf);
    println!("Graph:");
    for row in &adj_list {
        println!("{:?}", row);
    }
    println!("BFS using adjacency list:");
    let start = Instant::now();
    let distances = bfs_list(&adj_list, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    println!("DFS using matrix");
    let start = Instant::now();
    let distances = dfs_matrix(&graf, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);

    println!("DFS using adjacency list:");
    let start = Instant::now();
    let distances = dfs_list(&adj_list, 0);
    let duration = start.elapsed();
    println!("Distances: {:?}", distances);
    println!("Time elapsed: {:?}", duration);
}
*/
Final block vector: [
    LocalVecBlock {
        type: Start,
        text: "create_graph",
        x: 0,
        y: 0,
    },
    LocalVecBlock {
        type: Cycle,
        text: "for i in 0..size ",
        x: 0,
        y: 100,
    },
    LocalVecBlock {
        type: Cycle,
        text: "for j in i..size ",
        x: 0,
        y: 200,
    },
    LocalVecBlock {
        type: Condition,
        text: "if i == j ",
        x: 0,
        y: 300,
    },
    LocalVecBlock {
        type: Action,
        text: "continue",
        x: 100,
        y: 400,
    },
    LocalVecBlock {
        type: End,
        text: "end if",
        x: 100,
        y: 500,
    },
    LocalVecBlock {
        type: Action,
        text: "graf[i][j] = rng.gen::<u32>() % 2",
        x: 0,
        y: 500,
    },
    LocalVecBlock {
        type: Action,
        text: "graf[j][i] = graf[i][j]",
        x: 0,
        y: 600,
    },
    LocalVecBlock {
        type: End,
        text: "0:200",
        x: 0,
        y: 700,
    },
    LocalVecBlock {
        type: End,
        text: "0:100",
        x: 0,
        y: 800,
    },
    LocalVecBlock {
        type: End,
        text: "return graf",
        x: 0,
        y: 900,
    },
]
coords: x=0; y=0
coords: x=0; y=100
coords: x=0; y=200
coords: x=0; y=300
push iterator [3]
coords: x=100; y=400
enter in check funk
not more
coords: x=100; y=500
coords: x=0; y=500
enter in check funk
coords: x=0; y=600
enter in check funk
coords: x=0; y=700
index: 2
coords: x=0; y=800
index: 1
coords: x=0; y=900
